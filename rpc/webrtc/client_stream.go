package rpcwebrtc

import (
	"context"
	"errors"
	"sync"

	webrtcpb "go.viam.com/utils/proto/rpc/webrtc/v1"

	"github.com/edaniels/golog"
	"google.golang.org/grpc"
	"google.golang.org/grpc/metadata"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
)

var _ = grpc.ClientStream(&ClientStream{})

// A ClientStream is the high level gRPC streaming interface used for both
// unary and streaming call requests.
type ClientStream struct {
	*baseStream
	mu               sync.Mutex
	ch               *ClientChannel
	headers          metadata.MD
	trailers         metadata.MD
	userCtx          context.Context
	headersReceived  chan struct{}
	trailersReceived bool
}

// NewClientStream creates a gRPC stream from the given client channel with a
// unique identity in order to be able to recognize responses on a single
// underlying data channel.
func NewClientStream(
	ctx context.Context,
	channel *ClientChannel,
	stream *webrtcpb.Stream,
	onDone func(id uint64),
	logger golog.Logger,
) *ClientStream {
	ctx, cancel := context.WithCancel(ctx)
	bs := newBaseStream(ctx, cancel, stream, onDone, logger)
	s := &ClientStream{
		baseStream:      bs,
		ch:              channel,
		headersReceived: make(chan struct{}),
	}
	return s
}

// SendMsg is generally called by generated code. On error, SendMsg aborts
// the stream. If the error was generated by the client, the status is
// returned directly; otherwise, io.EOF is returned and the status of
// the stream may be discovered using RecvMsg.
//
// SendMsg blocks until:
//   - There is sufficient flow control to schedule m with the transport, or
//   - The stream is done, or
//   - The stream breaks.
//
// SendMsg does not wait until the message is received by the server. An
// untimely stream closure may result in lost messages. To ensure delivery,
// users should ensure the RPC completed successfully using RecvMsg.
//
// It is safe to have a goroutine calling SendMsg and another goroutine
// calling RecvMsg on the same stream at the same time, but it is not safe
// to call SendMsg on the same stream in different goroutines. It is also
// not safe to call CloseSend concurrently with SendMsg.
func (s *ClientStream) SendMsg(m interface{}) error {
	return s.writeMessage(m, false)
}

// Context returns the context for this stream.
//
// It should not be called until after Header or RecvMsg has returned. Once
// called, subsequent client-side retries are disabled.
func (s *ClientStream) Context() context.Context {
	return s.userCtx
}

// Header returns the header metadata received from the server if there
// is any. It blocks if the metadata is not ready to read.
func (s *ClientStream) Header() (metadata.MD, error) {
	select {
	case <-s.ctx.Done():
		return nil, s.ctx.Err()
	case <-s.headersReceived:
		return s.headers, nil
	}
}

// Trailer returns the trailer metadata from the server, if there is any.
// It must only be called after stream.CloseAndRecv has returned, or
// stream.Recv has returned a non-nil error (including io.EOF).
func (s *ClientStream) Trailer() metadata.MD {
	s.mu.Lock()
	defer s.mu.Unlock()
	return s.trailers
}

// CloseSend closes the send direction of the stream. It closes the stream
// when non-nil error is met. It is also not safe to call CloseSend
// concurrently with SendMsg.
func (s *ClientStream) CloseSend() error {
	return s.writeMessage(nil, true)
}

func (s *ClientStream) writeHeaders(headers *webrtcpb.RequestHeaders) (err error) {
	defer func() {
		if err != nil {
			s.closeWithRecvError(err)
		}
	}()
	return s.ch.writeHeaders(s.stream, headers)
}

var maxRequestMessagePacketDataSize int

func init() {
	md, err := proto.Marshal(&webrtcpb.Request{
		Stream: &webrtcpb.Stream{
			Id: 1,
		},
		Type: &webrtcpb.Request_Message{
			Message: &webrtcpb.RequestMessage{
				PacketMessage: &webrtcpb.PacketMessage{Eom: true},
			},
		},
	})
	if err != nil {
		panic(err)
	}
	// max msg size - packet size - msg type size - proto padding (?)
	maxRequestMessagePacketDataSize = maxDataChannelSize - len(md) - 1
}

func (s *ClientStream) writeMessage(m interface{}, eos bool) (err error) {
	defer func() {
		if err != nil {
			s.closeWithRecvError(err)
		}
	}()

	var data []byte
	if m != nil {
		data, err = proto.Marshal(m.(proto.Message))
		if err != nil {
			return
		}
	}

	if len(data) == 0 {
		return s.ch.writeMessage(s.stream, &webrtcpb.RequestMessage{
			HasMessage: m != nil,
			PacketMessage: &webrtcpb.PacketMessage{
				Eom: true,
			},
			Eos: eos,
		})
	}

	for len(data) != 0 {
		amountToSend := maxRequestMessagePacketDataSize
		if len(data) < amountToSend {
			amountToSend = len(data)
		}
		packet := &webrtcpb.PacketMessage{
			Data: data[:amountToSend],
		}
		data = data[amountToSend:]
		if len(data) == 0 {
			packet.Eom = true
		}
		if err := s.ch.writeMessage(s.stream, &webrtcpb.RequestMessage{
			HasMessage:    m != nil,
			PacketMessage: packet,
			Eos:           eos,
		}); err != nil {
			return err
		}
	}
	return nil
}

func (s *ClientStream) onResponse(resp *webrtcpb.Response) {
	switch r := resp.Type.(type) {
	case *webrtcpb.Response_Headers:
		select {
		case <-s.headersReceived:
			s.closeWithRecvError(errors.New("headers already received"))
			return
		default:
		}
		if s.trailersReceived {
			s.closeWithRecvError(errors.New("headers received after trailers"))
			return
		}
		s.processHeaders(r.Headers)
	case *webrtcpb.Response_Message:
		select {
		case <-s.headersReceived:
		default:
			s.closeWithRecvError(errors.New("headers not yet received"))
			return
		}
		if s.trailersReceived {
			s.closeWithRecvError(errors.New("message received after trailers"))
			return
		}
		s.processMessage(r.Message)
	case *webrtcpb.Response_Trailers:
		s.processTrailers(r.Trailers)
	default:
		s.baseStream.logger.Errorf("unknown response type %T", r)
	}
}

func (s *ClientStream) processHeaders(headers *webrtcpb.ResponseHeaders) {
	s.headers = metadataFromProto(headers.Metadata)
	s.userCtx = metadata.NewIncomingContext(s.ctx, s.headers)
	close(s.headersReceived)
}

func (s *ClientStream) processMessage(msg *webrtcpb.ResponseMessage) {
	if s.trailersReceived {
		s.logger.Error("message received after trailers")
		return
	}
	data, eop := s.baseStream.processMessage(msg.PacketMessage)
	if !eop {
		return
	}
	s.msgCh <- data
}

func (s *ClientStream) processTrailers(trailers *webrtcpb.ResponseTrailers) {
	s.mu.Lock()
	metadataFromProto(trailers.Metadata)
	s.mu.Unlock()
	s.trailersReceived = true
	respStatus := status.FromProto(trailers.Status)
	s.closeWithRecvError(respStatus.Err())
}
